#!/usr/bin/env python3
import csv
import logging
import pika
import time
from waggle.protocol.v0 import *


formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
ch.setFormatter(formatter)

logger = logging.getLogger('message-router')
logger.setLevel(logging.DEBUG)
logger.addHandler(ch)


def compile_rules(rules):
    table = {}

    for rule, action in rules:
        ordered_rule = sorted(rule.items())
        keys = tuple(k for k, v in ordered_rule)
        vals = tuple(v for k, v in ordered_rule)

        if keys not in table:
            table[keys] = {}

        try:
            table[keys][vals] = globals()[action]
        except KeyError:
            logger.warning('No action "%s" defined.', action)

    return table


def get_actions_for_message(message):
    for keys, patterns in rule_table.items():
        try:
            vals = tuple(message[key] for key in keys)
        except KeyError:
            continue

        try:
            action = patterns[vals]
        except KeyError:
            continue

        yield action


def get_mailbox_for_receiver_id(receiver_id):
    return receiver_id.decode()


queue_declared = {}


def route_to_receiver(ch, message):
    logger.info('Routing message from %s to %s.', message['sender_id'], message['receiver_id'])
    mailbox = get_mailbox_for_receiver_id(message['receiver_id'])
    ch.queue_declare(queue=mailbox, durable=True)
    ch.basic_publish(exchange='', routing_key=mailbox, body=pack_waggle_packets([message]))


def get_mailbox_for_datagram(datagram):
    return 'in-plugin-{}-{}-{}'.format(
        datagram['plugin_id'],
        datagram['plugin_major_version'],
        datagram['plugin_instance'])

# can keep an internal table of name mappings, too.

def deploy_package(ch, message):
    logger.info('Deploying packages on %s: %s', message['receiver_id'], message['body'].decode())


def log_test_message(ch, message):
    logger.info('Got test message for %s!', message)


def route_to_plugin(ch, message):
    try:
        datagrams = unpack_datagrams(message['body'])
    except ValueError:
        logger.info('Dropping invalid datagrams.')
        return

    for datagram in datagrams:
        logger.info('Routing datagram to plugin %s %s %s.', datagram['plugin_id'], datagram['plugin_major_version'], datagram['plugin_instance'])
        mailbox = get_mailbox_for_datagram(datagram)
        ch.queue_declare(queue=mailbox, durable=True)
        ch.basic_publish('', mailbox, pack_datagrams([datagram]))


def do_actions_for_message(ch, message):
    for action in get_actions_for_message(message):
        action(ch, message)


def process_message(ch, method, properties, body):
    for message in unpack_waggle_packets(body):
        do_actions_for_message(ch, message)

    ch.basic_ack(delivery_tag=method.delivery_tag)


def get_rabbitmq_connection():
    logger.info('Connecting to RabbitMQ server.')

    credentials = pika.PlainCredentials(
        username='admin',
        password='admin')

    parameters = pika.ConnectionParameters(
        host='localhost',
        credentials=credentials,
        virtual_host='beehive')

    connection = pika.BlockingConnection(parameters)

    logger.info('Connected to RabbitMQ server.')

    return connection


def declare_incoming_message_queue(channel):
    channel.queue_declare(queue='messages', durable=True)


def declare_mailbox_queues(channel):
    for _, receiver_id, _ in routing_table:
        mailbox = get_mailbox_for_receiver_id(receiver_id)
        channel.queue_declare(queue=mailbox, durable=True)


def declare_queues(channel):
    logger.info('Declaring message queues.')
    declare_incoming_message_queue(channel)
    # declare_mailbox_queues(channel)


def start_message_processor(channel):
    logger.info('Starting message processor.')
    channel.basic_consume(process_message, 'messages')

    try:
        channel.start_consuming()
    finally:
        logger.info('Stopped message processor.')


def start_routing():
    connection = get_rabbitmq_connection()
    channel = connection.channel()
    declare_queues(channel)
    start_message_processor(channel)


admin = b'admin'.rjust(16, b' ')
node1 = b'node1'.rjust(16, b' ')
node2 = b'node2'.rjust(16, b' ')

rule_table = compile_rules([
    ({'sender_id': admin, 'message_major_type': 0}, 'route_to_receiver'),
    ({'sender_id': admin, 'message_major_type': 1}, 'route_to_receiver'),

    # node type rules
    # ({'receiver_id': b'0000000000000001', 'message_major_type': 0}, 'route_to_plugin'),
    # ({'receiver_id': b'0000000000000001', 'message_major_type': 1}, 'deploy_package'),

    # debugging
    ({'message_major_type': 255}, 'log_test_message'),
])


if __name__ == '__main__':
    while True:
        try:
            start_routing()
        except KeyboardInterrupt:
            break
        except Exception:
            logger.exception('Unhandled exception occurred. Will retry...')
            time.sleep(5)
